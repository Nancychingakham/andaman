{
  "entityType" : "CONVERTER",
  "entity" : {
    "additionalInfo" : {
      "description" : ""
    },
    "configuration" : {
      "scriptLang" : "JS",
      "decoder" : "// Decode payload to JSON object\nvar decodedPayload = decodeToJson(payload);\n\n// Extract necessary information\nvar deviceName = decodedPayload.end_device_ids.device_id;\nvar deviceType = 'default';\nvar telemetry = {\n    \"Air Temperature\": decodedPayload.uplink_message.decoded_payload.messages[0].measurementValue,\n    \"Air Humidity\": decodedPayload.uplink_message.decoded_payload.messages[1].measurementValue,\n    \"Light Intensity\": decodedPayload.uplink_message.decoded_payload.messages[2].measurementValue,\n    \"UV Index\": decodedPayload.uplink_message.decoded_payload.messages[3].measurementValue,\n    \"Wind Speed\": decodedPayload.uplink_message.decoded_payload.messages[4].measurementValue,\n    \"Wind Direction Sensor\": decodedPayload.uplink_message.decoded_payload.messages[5].measurementValue,\n    \"Rain Gauge\": decodedPayload.uplink_message.decoded_payload.messages[6].measurementValue,\n    \"Barometric Pressure\": decodedPayload.uplink_message.decoded_payload.messages[7].measurementValue,\n    // These values are not provided in the JSON data, assuming placeholders for now\n    \"hotspot_name\": \"\", // Set hotspot name here\n    \"hotspot_lat\": \"\",  // Set hotspot latitude here\n    \"hotspot_long\": \"\", // Set hotspot longitude here\n    \"hotspot_freq\": \"\", // Set hotspot frequency here\n    \"battery\": \"\",      // Set battery value here\n};\n\n// Construct result object\nvar result = {\n    deviceName: deviceName,\n    deviceType: deviceType,\n    telemetry: telemetry\n};\n\n// Function to decode payload from bytes to string\nfunction decodeToString(payload) {\n    return String.fromCharCode.apply(String, payload);\n}\n\n// Function to parse string to JSON object\nfunction decodeToJson(payload) {\n    var str = decodeToString(payload);\n    var data = JSON.parse(str);\n    return data;\n}\n\n// Return result object\nreturn result;",
      "tbelDecoder" : "var data = decodeToJson(payload);\n\nvar deviceName = data.end_device_ids.device_id;\nvar deviceType = data.end_device_ids.application_ids.application_id;\nvar groupName = 'IAQ devices';\n// var customerName = 'Customer A';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// If you want to parse incoming data somehow, you can add your code to this function.\n// input: bytes\n// expected output:\n//  {\n//    \"attributes\": {\"attributeKey\": \"attributeValue\"},\n//    \"telemetry\": {\"telemetryKey\": \"telemetryValue\"}\n//  }\n//\n// In the example - bytes will be saved as HEX string and also parsed as light level, battery level and PIR sensor value.\n//\n\nfunction decodeFrmPayload(input) {\n    var output = { attributes:{}, telemetry: {}};\n    // --- Decoding code --- //\n\n    output.telemetry.HEX_bytes = bytesToHex(input);\n\n    // If the length of the input byte array is odd - we cannot parse it using the example below\n    if (input.length > 0) {\n        for (var i = 0; i < input.length; ) {\n            var channel_id = input[i++];\n            if (i < input.length) {\n                var channel_type = input[i++];\n                // BATTERY\n                if (channel_id === 0x01 && channel_type === 0x75) {\n                    output.telemetry.battery = input[i];\n                    i += 1;\n                }\n                // PIR\n                else if (channel_id === 0x03 && channel_type === 0x00) {\n                    output.telemetry.pir = input[i] === 0 ? \"normal\" : \"trigger\";\n                    i += 1;\n                }\n                // DAYLIGHT\n                else if (channel_id === 0x04 && channel_type === 0x00) {\n                    output.telemetry.daylight = input[i] === 0 ? \"dark\" : \"light\";\n                    i += 1;\n                }\n            }\n        }\n    }\n\n    // --- Decoding code --- //\n    return output;\n}\n\n// --- attributes and telemetry objects ---\nvar telemetry = {};\nvar attributes = {};\n// --- attributes and telemetry objects ---\n\n// --- Timestamp parsing\nvar dateString = data.uplink_message.received_at;\n// If data is simulated or device doesn't send his own date string - we will use date from upcoming message, set by network server\nif ((data.simulated != null && data.simulated) || dateString == null) {\n    dateString = data.received_at;\n}\nvar timestamp = new Date(dateString).getTime();\nvar timestamp = -1;\nif (dateString != null) {\n  timestamp = new Date(dateString).getTime();\n  if (timestamp == -1) {\n      var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n      var millisecondsEndIndex = dateString.lastIndexOf('+');\n      if (millisecondsEndIndex == -1) {\n          millisecondsEndIndex = dateString.lastIndexOf('Z');\n      }\n      if (millisecondsEndIndex == -1) {\n          millisecondsEndIndex = dateString.lastIndexOf('-');\n      }\n      if (millisecondsEndIndex == -1) {\n          if (dateString.length >= secondsSeparatorIndex + 3) {\n              dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n          }\n      } else {\n          dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n              dateString.substring(millisecondsEndIndex, dateString.length);\n      }\n      timestamp = new Date(dateString).getTime();\n  }\n}\n// If we cannot parse timestamp - we will use the current timestamp\nif (timestamp == -1) {\n    timestamp = Date.now();\n}\n// --- Timestamp parsing\n\n// You can add some keys manually to attributes or telemetry\nattributes.devEui = data.end_device_ids.dev_eui;\nattributes.fPort = data.uplink_message.f_port;\n// We want to save correlation ids as single object, so we are excluding them from attributes parse and add manually\nattributes.correlation_ids = data.correlation_ids;\n\n// You can exclude some keys from the result\nvar excludeFromTelemetryList = [\"uplink_token\", \"gateway_id\", \"settings\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"network_ids\"];\nvar excludeFromAttributesList = [\"uplink_token\", \"gateway_id\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"session_key_id\", \"dev_eui\"];\n\n// Message parsing\n// To avoid paths in the decoded objects we passing false value to function as \"pathInKey\" argument.\n// Warning: pathInKey can cause already found fields to be overwritten with the last value found, e.g. receive_at from uplink_message will be written receive_at in the root.\nvar telemetryData = toFlatMap(data.uplink_message, excludeFromTelemetryList, false);\nvar attributesData = {};\nattributesData.putAll(toFlatMap(data.uplink_message.settings, excludeFromAttributesList, false));\nattributesData.putAll(toFlatMap(data.uplink_message.network_ids, excludeFromAttributesList, false));\nattributesData.putAll(toFlatMap(data.end_device_ids, excludeFromAttributesList, false));\n\n// Passing incoming bytes to decodeFrmPayload function, to get custom decoding\nvar customDecoding = {};\nif (data.uplink_message.get(\"frm_payload\") != null) {\n  customDecoding = decodeFrmPayload(base64ToBytes(data.uplink_message.frm_payload));\n}\n\n// Collecting data to result\nif (customDecoding.?telemetry.size() > 0) {\n    telemetry.putAll(customDecoding.telemetry);\n}\n\nif (customDecoding.?attributes.size() > 0) {\n    attributes.putAll(customDecoding.attributes);\n}\n\ntelemetry.putAll(telemetryData);\nattributes.putAll(attributesData);\n\nvar result = {\n    deviceName: deviceName,\n    deviceType: deviceType,\n//  assetName: assetName,\n//  assetType: assetType,\n//  customerName: customerName,\n    groupName: groupName,\n    attributes: attributes,\n    telemetry: {\n        ts: timestamp,\n        values: telemetry\n    }\n};\n\nreturn result;",
      "encoder" : null,
      "tbelEncoder" : null,
      "updateOnlyKeys" : [ "devEui", "fPort", "bandwidth", "spreading_factor", "coding_rate", "frequency", "net_id", "tenant_id", "cluster_id", "cluster_address", "device_id", "application_id", "join_eui", "dev_addr", "battery", "pir", "daylight", "eui" ]
    },
    "debugMode" : true,
    "edgeTemplate" : false,
    "externalId" : null,
    "id" : {
      "entityType" : "CONVERTER",
      "id" : "0ad2cae0-3aab-11ef-83a8-912a659b4106"
    },
    "name" : "weatherUplinkDataConverter",
    "type" : "UPLINK"
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}